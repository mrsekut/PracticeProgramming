{"version":3,"sources":["assembly/index.ts","~lib/memory.ts"],"names":[],"mappings":"gTAkBc,KACV,EAAU,UAGmC,EAA9B,KAAU,MAAM,KAAU,WAG7B,AAAL,QAGK,AAAL,QAUP,EAAU,QAGV,EAAU,QAOS,AAAd,EAFc,EAAG,IAER,EADI,EAAG,mCA9BF,KAAY","sourceRoot":"assemblyscript:///","sourceContents":["// export class Vec_3 {\n//   constructor(public x: f64 = 0.0, public y: f64 = 0.0, public z: f64 = 0.0) {}\n\n//   @inline\n//   @operator('+')\n//   protected add_vector(value: Vec_3): Vec_3 {\n//     return new Vec_3(this.x + value.x, this.y + value.y, this.z + value.z);\n//   }\n\n//   public get length(): f64 {\n//     return Math.sqrt(this.x * this.x + this.y * this.y + this.z + this.z);\n//   }\n// }\n\nexport class Vec {\n  mX: i32;\n  mY: i32;\n  constructor(x: i32 = 0, y: i32 = 0) {\n    this.mX = x;\n    this.mY = y;\n  }\n  add(b: Vec): Vec {\n    return new Vec(this.mX + b.mX, this.mY + b.mY);\n  }\n  getX(): i32 {\n    return this.mX;\n  }\n  getY(): i32 {\n    return this.mY;\n  }\n\n  get x(): i32 {\n    return this.mX;\n  }\n  get y(): i32 {\n    return this.mY;\n  }\n  set x(value: i32) {\n    this.mX = value;\n  }\n  set y(value: i32) {\n    this.mY = value;\n  }\n}\n\nexport function init(): i32 {\n  const zero = new Vec(1, 0);\n  const one = new Vec(2, 3);\n  return zero.add(one).x;\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n"]}