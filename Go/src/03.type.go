// ============================
//
// 値型
//
// ============================

// 論理値型
// ============================

// bool

var b bool
fmt.Printf("b: %T\n", b)

// 数値型
// ============================

// int 符号付き整数型
i8 := int8(127)
i16 := int16(127)
i32 := int32(127)
i64 := int64(127)
fmt.Printf("i8: %T, i16: %T, i32: %T, i64: %T\n", i8, i16, i32, i64)


// int 符号なし整数型
i8 := uint8(127)
i16 := uint16(127)
i32 := uint32(127)
i64 := uint64(127)
fmt.Printf("i8: %T, i16: %T, i32: %T, i64: %T\n", i8, i16, i32, i64)

// int
i := 10
fmt.Printf("i: %T", i)

// float 浮動小数点型
f32 := float32(127)
f64 := 127.0
fmt.Printf("f32: %T, f64: %T\n", f32, f64)

// 複素数型
c := 1.0 + 3i // or complex(1, 3)
d := complex64(c)
fmt.Printf("%T\n", c)
fmt.Printf("%T\n", d)

real(c) // == 1.0
imag(c) // == 3.0


// 文字列型
// ============================

// rune型
// 文字列型の定数
// Unicodeコードポイントを表す特殊な整数型
r := '松' // single quote
fmt.Printf("%T", r)

// string
s := "abc"
fmt.Printf("s: %T\n", s)


// 配列型
// ============================

a := [...]int{1, 2, 3, 4, 5}
fmt.Printf("%T", a)


// interface{}型
// ============================

var x interface{}
fmt.Printf("%T", x) // => <nil>


// ============================
//
// 参照型
// - make関数をつかって生成する
// ============================

// slice
// ============================
// 可変長配列

s := []int{1, 2, 3}
s = append(s, 8, 12, 34) // 追加
t := make([]int, len(s)) // sと同じ大きさのsliceを宣言
copy(t, s) // コピー
fmt.Println(t)

s1 := make([]int, 5, 10) // 第三引数で容量を指定できる
fmt.Println(len(s1)) // 要素数
fmt.Println(cap(s1)) // 容量

s := []int{1, 2, 3}
s = append(s, 4, 5, 6) // appendで要素を追加

s1 := []int{1, 2, 3}
s2 := []int{4, 5, 6}
s3 := append(s1, s2...) // sliceにsliceを追加するときは`...``を付ける

// map
// ============================

// channel
// ============================

// ============================
// ポインタ型
// ============================
